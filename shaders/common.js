export default "precision highp float;\nprecision highp sampler2D;\n\nuniform vec2 texelSize;\nuniform int iFrame;\nuniform int tar;\nuniform float iTime;\nuniform float dt;\nuniform vec4 iMouse;\n\n\nuniform sampler2D X_XT;\nuniform sampler2D X_YT;\nuniform sampler2D V_XT;\nuniform sampler2D V_YT;\nuniform sampler2D MT;\nuniform sampler2D CT;\n\n#define iResolution (vec2((1./texelSize)))\n\n#define V_S 1.\n#define X_S 0.5\n#define M_M 8.0\n#define R (vec2(vec2((1./texelSize))))\n#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a,p) texture2D(a,((p-.5)+.5)/R)\n//texelFetch(a, Bi(p), 0)\n#define pixel(a,p) texture2D(a,(p)/R)\n\n\n#define LE true\n#define PI 3.14159265\n\n#define loop(i,x)for(int i=0;i<x;i++)\n#define range(i,a,b)for(int i=a;i<=b;i++)\n\n#define border_h 10.\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho .5\n\nfloat smoothstepp(float a,float b,float c){\n    return smoothstep(a,b,c);//(c-a)/(b-a);\n}\nfloat shiftRight (float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\nfloat shiftLeft (float v, float amt) {\n    return floor(v * exp2(amt) + 0.5);\n}\nfloat maskLast (float v, float bits) {\n    return mod(v, shiftLeft(1.0, bits));\n}\nfloat extractBits (float num, float from, float to) {\n    from = floor(from + 0.5); to = floor(to + 0.5);\n    return maskLast(shiftRight(num, from), to - from);\n}\nvec4 encode01FloatIntoColorVec4(float p){\n    vec4 v;\n    float pr=floor((256.0*256.0-1.0)*clamp(p,0.0,1.0)+0.5);\n    v.x=mod(pr,256.0)/255.0;\n    v.y=floor(pr/256.0)/255.0;\n    return v;\n}\n\nfloat decode01FloatFromColorVec4(vec4 v){\n    vec2 v2=floor(clamp(v.xy,0.0,1.0)*255.0);\n    return (256.0*v2.y+v2.x)/(256.0*256.0-1.0);\n}\nvec4 encode01FloatIntoColorVec4r(float p){\n    vec4 v;\n    float pr=floor((256.0*256.0*256.0*256.0-1.0)*clamp(p,0.0,1.0)+0.5);\n    v.x=floor(mod(pr,256.0))/255.0;\n    v.y=floor(mod(pr/256.0,256.0))/255.0;\n    v.z=floor(mod(pr/256.0/256.0,256.0))/255.0;\n    v.w=floor(mod(pr/256.0/256.0/256.0,256.0))/255.0;\n    return v;\n}\n\nfloat decode01FloatFromColorVec4r(vec4 v){\n    vec4 v2=floor(clamp(v.xyzw,0.0,1.0)*255.0);\n    return (256.0*256.0*256.0*v2.w+256.0*256.0*v2.z+256.0*v2.y+v2.x)/(256.0*256.0*256.0*256.0-1.0);\n}\n\nvec4 floatToRgba(float texelFloat, bool littleEndian) {\n    return encode01FloatIntoColorVec4((texelFloat+1.0)/2.0);\n    if (texelFloat == 0.0) return vec4(0, 0, 0, 0);\n    float sign = texelFloat > 0.0 ? 0.0 : 1.0;\n    texelFloat = abs(texelFloat);\n    float exponent = floor(log2(texelFloat));\n    float biased_exponent = exponent + 127.0;\n    float fraction = ((texelFloat / exp2(exponent)) - 1.0) * 8388608.0;\n    float t = biased_exponent / 2.0;\n    float last_bit_of_biased_exponent = fract(t) * 2.0;\n    float remaining_bits_of_biased_exponent = floor(t);\n    float byte4 = extractBits(fraction, 0.0, 8.0) / 255.0;\n    float byte3 = extractBits(fraction, 8.0, 16.0) / 255.0;\n    float byte2 = (last_bit_of_biased_exponent * 128.0 + extractBits(fraction, 16.0, 23.0)) / 255.0;\n    float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\n    return (\n      littleEndian\n      ? vec4(byte4, byte3, byte2, byte1)\n      : vec4(byte1, byte2, byte3, byte4)\n    );\n}\n\n\n\n// Denormalize 8-bit color channels to integers in the range 0 to 255.\nivec4 floatsToBytes(vec4 inputFloats, bool littleEndian) {\n  ivec4 bytes = ivec4(inputFloats * 255.0);\n  return (\n    littleEndian\n    ? bytes.abgr\n    : bytes\n  );\n}\n\n// Break the four bytes down into an array of 32 bits.\nvoid bytesToBits(const in ivec4 bytes, out bool bits[32]) {\n  for (int channelIndex = 0; channelIndex < 4; ++channelIndex) {\n    float acc = float(bytes[channelIndex]);\n    for (int indexInByte = 7; indexInByte >= 0; --indexInByte) {\n      float powerOfTwo = exp2(float(indexInByte));\n      bool bit = acc >= powerOfTwo;\n      bits[channelIndex * 8 + (7 - indexInByte)] = bit;\n      acc = mod(acc, powerOfTwo);\n    }\n  }\n}\n\n// Compute the exponent of the 32-bit float.\nfloat getExponent(bool bits[32]) {\n  const int startIndex = 1;\n  const int bitStringLength = 8;\n  const int endBeforeIndex = startIndex + bitStringLength;\n  float acc = 0.0;\n  int pow2 = bitStringLength - 1;\n  for (int bitIndex = startIndex; bitIndex < endBeforeIndex; ++bitIndex) {\n    acc += float(bits[bitIndex]) * exp2(float(pow2--));\n  }\n  return acc;\n}\n\n// Compute the mantissa of the 32-bit float.\nfloat getMantissa(bool bits[32], bool subnormal) {\n  const int startIndex = 9;\n  const int bitStringLength = 23;\n  const int endBeforeIndex = startIndex + bitStringLength;\n  // Leading/implicit/hidden bit convention:\n  // If the number is not subnormal (with exponent 0), we add a leading 1 digit.\n  float acc = float(!subnormal) * exp2(float(bitStringLength));\n  int pow2 = bitStringLength - 1;\n  for (int bitIndex = startIndex; bitIndex < endBeforeIndex; ++bitIndex) {\n    acc += float(bits[bitIndex]) * exp2(float(pow2--));\n  }\n  return acc;\n}\n\n// Parse the float from its 32 bits.\nfloat bitsToFloat(bool bits[32]) {\n  float signBit = float(bits[0]) * -2.0 + 1.0;\n  float exponent = getExponent(bits);\n  bool subnormal = abs(exponent - 0.0) < 0.01;\n  float mantissa = getMantissa(bits, subnormal);\n  float exponentBias = 127.0;\n  return signBit * mantissa * exp2(exponent - exponentBias - 23.0);\n}\n\n// Decode a 32-bit float from the RGBA color channels of a texel.\nfloat rgbaToFloat(vec4 texelRGBA, bool littleEndian) {\n\n    return decode01FloatFromColorVec4(texelRGBA)*2.0-1.0;\n  ivec4 rgbaBytes = floatsToBytes(texelRGBA, littleEndian);\n  bool bits[32];\n  bytesToBits(rgbaBytes, bits);\n  return bitsToFloat(bits);\n}\n\n\nvec2 encode01FloatIntoColorVec2(float p){\n    vec2 v;\n    float pr=floor((256.0*256.0-1.0)*clamp(p,0.0,1.0));\n    v.x=mod(pr,256.0)/255.0;\n    v.y=floor(pr/256.0)/255.0;\n    return v;\n}\n\nfloat decode01FloatFromColorVec2(vec2 v){\n    vec2 v2=floor(clamp(v,0.0,1.0)*255.0);\n    return (256.0*v2.y+v.x)/(256.0*256.0-1.0);\n}\n\n\n\nfloat Pf(float rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF=1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(.5*rho,.04*rho*(rho/fluid_rho-1.),GF);//water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang),-sin(ang),sin(ang),cos(ang));\n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang),sin(ang));\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat border(vec2 p)\n{\n    float bound=max(-sdBox(p-R*vec2(.5,.2),R*vec2(.5,.2)),-sdBox(p-R*vec2(.5,.8),R*vec2(1.0,.6)));\n    return bound;\n    // float box=sdBox(Rot(0.*time)*(p-R*vec2(.5,.6)),R*vec2(.05,.01));\n    // float drain=-sdBox(p-R*vec2(.5,.7),R*vec2(1.5,.5));\n    // vec2 pg=p-R*vec2(.5,.5);\n    // return min(max(drain,min(bound,box)),(length(p-R*vec2(iMouse.x,iMouse.y))-10.));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx=vec3(-h,0,h);\n    vec4 idx=vec4(-1./h,0.,1./h,.25);\n    vec3 r=idx.zyw*border(p+dx.zy)\n    +idx.xyw*border(p+dx.xy)\n    +idx.yzw*border(p+dx.yz)\n    +idx.yxw*border(p+dx.yx);\n    return vec3(normalize(r.xy),r.z+1e-4);\n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    float M;\n    vec3 C;\n};\nstruct vec8\n{\n    float x;\n    float y;\n    float z;\n    float w;\n    float r;\n    float g;\n    float b;\n    float a;\n};\n\nparticle getParticle(vec2 p)\n{\n    particle P;\n    P.X=vec2(rgbaToFloat(texture2D(X_XT,p/R).rgba,LE),rgbaToFloat(texture2D(X_XT,p/R).barg,LE))*X_S+p;\n    P.V=vec2(rgbaToFloat(texture2D(V_XT,p/R).rgba,LE),rgbaToFloat(texture2D(V_XT,p/R).barg,LE))*V_S;\n    P.M=decode01FloatFromColorVec4r(texture2D(MT,p/R))*M_M;\n    P.C=texture2D(CT,p/R).xyz;\n    return P;\n}\n\nvec4 saveParticle(particle P,vec2 pos)\n{\n    if(pos.x<1.0 || pos.y<1.0 || pos.x>R.x-1.0 || pos.y>R.y-1.0){\n        P.M=0.;\n    }\n    P.X=P.X-pos;\n    P.X=clamp(P.X,vec2(-X_S),vec2(X_S))/X_S;\n    P.V=clamp(P.V,vec2(-V_S),vec2(V_S))/V_S;\n    // vec2 XSQ=(P.X-vec2(-X_S))/(2.0*X_S);\n    // vec2 VSQ=(P.V-vec2(-V_S))/(2.0*V_S);\n    if(tar==0){\n        return vec4(floatToRgba(P.X.x,LE).rg,floatToRgba(P.X.y,LE).rg);//vec4(encode01FloatIntoColorVec2(XSQ.x),encode01FloatIntoColorVec2(XSQ.y));\n    }else if(tar==1){\n        return floatToRgba(P.X.y,LE);\n        // return vec4(encode01FloatIntoColorVec2(VSQ.x),encode01FloatIntoColorVec2(VSQ.y));\n    }else if(tar==2){\n        return vec4(floatToRgba(P.V.x,LE).rg,floatToRgba(P.V.y,LE).rg);//floatToRgba(P.V.x,LE);\n        // return vec4(encode01FloatIntoColorVec2(VSQ.x),encode01FloatIntoColorVec2(VSQ.y));\n    }else if(tar==3){\n        return floatToRgba(P.V.y,LE);\n        // return vec4(encode01FloatIntoColorVec2(VSQ.x),encode01FloatIntoColorVec2(VSQ.y));\n    }else if(tar==4){\n        return encode01FloatIntoColorVec4r(min(max(P.M,0.),M_M)/M_M);// prevent's screen whipe\n        // return vec4(encode01FloatIntoColorVec2(VSQ.x),encode01FloatIntoColorVec2(VSQ.y));\n    }else{\n        return vec4(P.C,1.0);// prevent's screen whipe\n    }\n}\n\nvec3 hash32(vec2 p)\n{\n    vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.1030,.0973));\n    p3+=dot(p3,p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x,vec2 p,float K)\n{\n    vec2 omin=clamp(x-K*.5,p-.5,p+.5);\n    vec2 omax=clamp(x+K*.5,p-.5,p+.5);\n    return vec3(.5*(omin+omax),(omax.x-omin.x)*(omax.y-omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nparticle Reintegration(vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    particle P;\n    P.X=vec2(0.);\n    P.V=vec2(0.);\n    P.M=0.;\n    P.C=vec3(0.);\n\n    range(i,-2,2)range(j,-2,2)\n    {\n        vec2 tpos=pos+vec2(i,j);\n        // vec8 data=texelish(ch,ch1,ch2,tpos);\n        \n        particle P0=getParticle(tpos);\n        \n        P0.X+=P0.V*dt;//integrate position\n        \n        float difR=.9+.21*smoothstepp(fluid_rho*0.,fluid_rho*.333,P0.M);\n        vec3 D=distribution(P0.X,pos,max(difR,0.0000001));\n        //the deposited mass into this cell\n        float m=P0.M*D.z;\n        \n        //add weighted by mass\n        P.X+=D.xy*m;\n        P.V+=P0.V*m;\n        P.C+=P0.C*m;\n        \n        //add mass\n        P.M+=m;\n    }\n    \n    //normalization\n    if(P.M>0.0)\n    {\n        P.X/=P.M;\n        P.V/=P.M;\n        P.C/=P.M;\n    }else{\n        P.M=0.;\n        P.C=vec3(0.);\n        P.V=vec2(0.);\n    }\n    return P;\n}\n\n//force calculation and integration\nparticle Simulation(in particle P,vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F=vec2(0.);\n    vec3 avgV=vec3(0.);\n    range(i,-2,2)range(j,-2,2)\n    {\n        vec2 tpos=pos+vec2(i,j);\n        particle P0=getParticle(tpos);\n        vec2 dx=P0.X-P.X;\n        float avgP=.5*P0.M*(Pf(P.M)+Pf(P0.M));\n        F-=.5*G(1.*dx)*avgP*dx;\n        avgV+=P0.M*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy/=avgV.z;\n    \n    //viscosity\n    F+=0.*P.M*(avgV.xy-P.V);\n    \n    //gravity\n    F+=P.M*vec2(0.,-.004);\n    \n    // if(Mouse.z>0.)\n    // {\n    //     vec2 dm=(Mouse.xy-Mouse.zw)/10.;\n    //     float d=distance(Mouse.xy,P.X)/20.;\n    //     F+=.001*dm*exp(-d*d);\n    //     // P.M.y += 0.1*exp(-40.*d*d);\n    // }\n    \n    //integrate\n    P.V+=F*dt/max(P.M,0.00000001);\n    \n    //border\n    vec3 N=bN(P.X);\n    float vdotN=step(N.z,border_h)*dot(-N.xy,P.V);\n    P.V+=.5*(N.xy*vdotN+N.xy*abs(vdotN));\n    P.V+=0.*P.M*N.xy*step(abs(N.z),border_h)*exp(-N.z);\n    \n    if(N.z<0.)P.V=vec2(0.);\n    \n    //velocity limit\n    float v=length(P.V);\n    P.V/=(v>1.)?v:1.;\n    return P;\n}\n\n"